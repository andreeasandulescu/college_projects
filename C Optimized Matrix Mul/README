//Sandulescu Andreea, 331CB

gcc:
------------------tema2_neopt
NEOPT SOLVER
TEST 1
	Time: 11.962293
NEOPT SOLVER
TEST 2
	Time: 19.554077
NEOPT SOLVER
TEST 3
	Time: 31.427088
NEOPT SOLVER
TEST 4
	Time: 47.706593
NEOPT SOLVER
TEST 5
	Time: 67.077705

------------------tema2_blas
BLAS SOLVER
TEST 1
	Time: 0.638504
BLAS SOLVER
TEST 2
	Time: 1.061568
BLAS SOLVER
TEST 3
	Time: 1.649047
BLAS SOLVER
TEST 4
	Time: 2.410868
BLAS SOLVER
TEST 5
	Time: 3.365243

------------------tema2_opt_f
NEOPT SOLVER
TEST 1
	Time: 1.059489
NEOPT SOLVER
TEST 2
	Time: 1.957945
NEOPT SOLVER
TEST 3
	Time: 3.524037
NEOPT SOLVER
TEST 4
	Time: 5.250717
NEOPT SOLVER
TEST 5
	Time: 7.362104


------------------tema2_opt_m
OPT SOLVER
TEST 1
	Time: 3.021794
OPT SOLVER
TEST 2
	Time: 4.610503
OPT SOLVER
TEST 3
	Time: 6.480148
OPT SOLVER
TEST 4
	Time: 10.161839
OPT SOLVER
TEST 5
	Time: 15.926249

----------------------------------------------------------------------
icc:
------------------tema2_neopt
NEOPT SOLVER
TEST 1
	Time: 1.959939
NEOPT SOLVER
TEST 2
	Time: 3.574588
NEOPT SOLVER
TEST 3
	Time: 5.242023
NEOPT SOLVER
TEST 4
	Time: 8.125756
NEOPT SOLVER
TEST 5
	Time: 11.984488

------------------tema2_blas
BLAS SOLVER
TEST 1
	Time: 0.510298
BLAS SOLVER
TEST 2
	Time: 0.860303
BLAS SOLVER
TEST 3
	Time: 1.360624
BLAS SOLVER
TEST 4
	Time: 2.031430
BLAS SOLVER
TEST 5
	Time: 3.032604

------------------tema2_opt_f
NEOPT SOLVER
TEST 1
	Time: 1.883700
NEOPT SOLVER
TEST 2
	Time: 3.368211
NEOPT SOLVER
TEST 3
	Time: 5.393513
NEOPT SOLVER
TEST 4
	Time: 7.689412
NEOPT SOLVER
TEST 5
	Time: 11.259285

------------------tema2_opt_m
OPT SOLVER
TEST 1
	Time: 1.407046
OPT SOLVER
TEST 2
	Time: 3.076418
OPT SOLVER
TEST 3
	Time: 4.790807
OPT SOLVER
TEST 4
	Time: 7.184140
OPT SOLVER
TEST 5
	Time: 10.296353


pentru blas:
Am apelat functia void cblas_zsyrk, cu parametrii gasiti in cblas.h (pentru CBLAS_LAYOUT row major, CBLAS_UPLO upper
triangular part, CBLAS_TRANSPOSE CblasNoTrans, deoarece am nevoie de A*A transpus, nu invers), cu dimensiunea N,
alpha si beta 1 (nu e nevoie sa inmultesc o variabila cu matricile A si C).

pentru varianta neopt:
Completez numai partea de deasupra diagonalei principale (j = i), parcurgand matricile cu doi pointeri(ptrA si ptrB).
De exemplu, pentru numarul complex aflat "la pozitia" i si j, partea reala se afla la ptrB =  B + (i * N * 2) + j * 2,
iar cea imaginara la ptrB + 1.Pastrez apoi in a1 si b1 numarul complex de pe pozitia (i,k) din matricea A si nr complex
aflat in matricea A pe pozitia (j,k) in a2 si b1.Inmultirea matricii A cu transpusa este acelasi lucru cu inmultirea
matricii A cu ea insasi, insa inmultind linie cu linie(coloana din transpusa este linie in A).
In final, apelez functia mul_elems, ce updateaza in real si img valorile corespunzatoare inumultirii celor 2 numere
complexe primite ca parametru.

pentru varianta opt_m:
Nu mai folosesc functia mul_elems, am mutat codul ei in my_solver, iar pointerii cu care parcurg matricea sunt doar
incrementati(sau adaug doar o constatnta (2*N)), fara a mai calcula pozitia necesara prin inmultiri cu variabile
(ex: A + (i * N * 2) + k * 2).
Astfel, pointerul ptrAI arata catre primul element din matricea A, linia i(in for-ul dupa i adaug mereu incr, care
reprezinta lungimea unei linii din matrice), iar ptrBI indica spre elementul de pe pozitia (i,i) (partea reala a 
numarului) (pentru i=0; i < 2*N; i+=2). Pe langa incr, adaug si un 2, deoarece nemaiexistand un j ca atare pe care
sa il inmultesc cu 2 si sa il adun la B( ptrBi = B + (i * N * 2) + j * 2), pentru j!= 0, de ex j = 3, la ptrBI (ce
indica spre linia i din B), trebuie adunat 6 initial (motiv pentru care adun cate 2, j fiind egal cu i initial).
Dupa aceasta operatie, pentru a calcula pozitia B[i][j], este nevoie doar sa adaug un 2 pentru fiecare incrementare
a j-ului(ptr_B_real += 2).Astfel, pentru numarul complex ce trebuie pus la pozitia B[i][j], voi pune partea reala
la ptr_B_real si cea imaginara la ptr_B_real + 1.
ptr_AJ_fin - 2 indica spre ultimul element al matricii A.
In locul buclei dupa j, am folosit bucla dupa ptrAJ, ce indica spre primul element din linia j a matricii A, la care
adun incr pentru a trece la urmatoarea linie pana la finalul matricii(ptr_AJ_fin)
In locul buclei dupa k, am folosit bucla dupa ptrAIK(ptrAIK = A[i][k], iar ptrAJK = A[j][k]).Cat timp nu am ajuns la
finalul liniei AIK, adun la cei doi pointeri 2 pentru a trece la urmatorul numar(partea sa reala) din linie, adunand
la ptr_B_real si ptr_B_real + 1 rezultatul inmultirii celor doua numere (i,k) si (j,k).
De asemenea, am folosit register pentru pointerii cu care parcurg matricea, lucru ce a adus o imbunatatire.

pentru varianta opt_f:
Pentru gcc, am folosit -o3, -funroll-loops pentru loop unrolling, -ftree-vectorize si -ffast-math pentru optimizari 
pe operatii floating-point, insa pentru icc am folosit doar -O3 si -unroll4 pentru loop unrolling, deoarece unele
din falgurile pentru gcc incetineau varianta pentru icc.

Mentionez ca varianta opt_m este de cel mult 4 ori mai lenta decat blas pe toate cele 5 teste folosind icc.